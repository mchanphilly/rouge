// Integer literals
125
-16
'h48454a
32'h48454a
8'o255
12'b101010
32'h_FF_FF_FF_FF

// Real literals
1.2
0.6
2.4E10 // exponent can be e or E
5e-3
325.761_452_e-10 // underscores are ignored
9.2e+4

// String literals
String easy_string = "abcd"
String string_with_escapes = "a\nb\nc"; // TODO: Recognize escaped characters separately.
// String octal_string = ??? (Manual is unclear what it means by \OOO or \xHH)

typedef Bit#(32) Word;

typedef enum {
    Good,
    Bad,
    Okay
} Status deriving (Eq);

typedef struct {
    Bit#(5) someIndex;
    Bool someBool;
} SomeItem deriving (Bits, Eq, FShow);

`define example_macro Reg#(Bit#(8))

interface SomeBufferInterface;
    method ActionValue#(SomeItem) remove_item;  // removes and returns item from buffer
    method Action add_item(SomeItem item);  // adds item to buffer
endinterface

(* synthesize *)
module mkSomeBuffer(SomeBufferInterface);
    Counter counter <- mkCounter;  // doesn't necessarily need to be named counter
    Reg#(Bit#(5)) raw_counter <- mkReg(0);
    Reg#(Bit#(8)) r <- mkReg(?); // donâ€™t-care value; usually we would use mkRegU instead
    
    function Action do_thing(Bit#(32) thing_input);
        action
            $display("Hex representation: %x", thing_input);

            if (thing_input == 16) begin
                $display("Halfway there!");
            end
        endaction
    endfunction

    function Action do_other_thing;
        action
            $display("Smoke test");
        endaction
    endfunction

    // etc. other state
    rule tick;
        counter.incr;
        do_thing(counter.value);
        raw_counter <= 0;
    endrule

    rule check_raw if (raw_counter == !0);
        $display("Something is wrong");
        $finish
    endrule

    method ActionValue#(SomeItem) remove_item if (counter.value != 0);
        let item <- some_removal_action;
        counter.decr;
        do_other_thing;
        return item;
    endmethod
    // etc. other methods/rules
endmodule