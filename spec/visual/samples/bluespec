import FIFO::*;

// Integer literals
Integer i1 = 125;
Integer i2 = -16;
Integer i3 = 'h48454a;
Integer i4 = 32'h48454a;
Integer i5 = 8'o255;
Integer i6 = 12'b101010;
Integer i7 = 32'h_FF_FF_FF_FF;

// Real literals
Real r1 = 1.2;
Real r2 = 0.6;
Real r3 = 2.4E10; // exponent can be e or E
Real r4 = 5e-3;
Real r5 = 325.761_452_e-10; // underscores are ignored
Real r6 = 9.2e+4;

// String literals
String easy_string = "abcd"
String string_with_escapes = "a\nb\nc"; // TODO: Recognize escaped characters separately.
// String octal_string = ??? (Manual is unclear what it means by \OOO or \xHH)

typedef Bit#(32) Word;

typedef enum {
    Good,
    Bad,
    Okay
} Status deriving (Eq);

typedef struct {
    Bit#(5) someIndex;
    Bool someBool;
} SomeItem deriving (Bits, Eq, FShow);

`define example_macro Reg#(Bit#(8))

interface SomeBufferInterface;
    method ActionValue#(SomeItem) remove_item;  // removes and returns item from buffer
    method Action add_item(SomeItem item);  // adds item to buffer
endinterface

(* synthesize *)
module mkSomeBuffer(SomeBufferInterface);
    Counter counter <- mkCounter;  // doesn't necessarily need to be named counter
    Reg#(Bit#(5)) raw_counter <- mkReg(0);
    Reg#(Bit#(8)) r <- mkReg(?); // donâ€™t-care value; usually we would use mkRegU instead
    Reg#(Status) status <- mkReg(Good);
    
    function Action do_thing(Bit#(32) thing_input);
        action
            $display("Hex representation: %x", thing_input);
            $display("First half: %3x", thing_input[31:16]);

            if (thing_input == 16) begin
                $display("Halfway there!");
            end
        endaction
    endfunction

    function Action do_other_thing;
        action
            $display("Smoke test");
        endaction
    endfunction

    (* conflict_free = "tick, check_raw" *)

    // etc. other state
    rule tick;
        counter.incr;
        do_thing(counter.value);
        raw_counter <= 0;
        
        if (status == Bad) status <= Good;

        if (status == Okay) begin
            status <= Good;
        end

        // For unpacking structs
        match Status {
            someIndex: .someIndex,
            someBool: .someBool
        } = counter.get_some_item;

        if (counter.dump matches tagged Valid .member &&& counter.id matches tagged Valid .id) begin
            $display("This is for conditional matching");
        end
    endrule

    rule check_raw if (raw_counter == !0);
        $display("Something is wrong");
        $finish;
    endrule

    method ActionValue#(SomeItem) remove_item if (counter.value != 0);
        let item <- some_removal_action;
        counter.decr;
        do_other_thing;

        case (status)
            Good: $display("Good!");
            Okay: begin
                $display("Okay");
            end
            Bad: $finish;
        endcase

        return item;
    endmethod
    // etc. other methods/rules
endmodule